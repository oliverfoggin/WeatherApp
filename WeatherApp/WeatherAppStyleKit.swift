//
//  WeatherAppStyleKit.swift
//  WeatherApp
//
//  Created by Oliver Foggin on 24/02/2017.
//  Copyright Â© 2017 . All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//



import UIKit

public class WeatherAppStyleKit : NSObject {

    //// Drawing Methods

    public dynamic class func drawWindVane(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 70, height: 70), resizing: ResizingBehavior = .aspectFit, windDirection: CGFloat = -56, windSpeed: CGFloat = 28.4) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 70, height: 70), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 70, y: resizedFrame.height / 70)


        //// Color Declarations
        let lightAir = UIColor(red: 0.761, green: 0.992, blue: 0.993, alpha: 1.000)
        var lightAirRedComponent: CGFloat = 1
        var lightAirGreenComponent: CGFloat = 1
        var lightAirBlueComponent: CGFloat = 1
        lightAir.getRed(&lightAirRedComponent, green: &lightAirGreenComponent, blue: &lightAirBlueComponent, alpha: nil)

        let calm = UIColor(red: (lightAirRedComponent * 0.7 + 0.3), green: (lightAirGreenComponent * 0.7 + 0.3), blue: (lightAirBlueComponent * 0.7 + 0.3), alpha: (lightAir.cgColor.alpha * 0.7 + 0.3))
        let lightBreeze = UIColor(red: 0.537, green: 0.979, blue: 0.758, alpha: 1.000)
        let gentleBreeze = UIColor(red: 0.533, green: 0.973, blue: 0.532, alpha: 1.000)
        let moderateBreeze = UIColor(red: 0.532, green: 0.969, blue: 0.331, alpha: 1.000)
        let freshBreeze = UIColor(red: 0.530, green: 0.966, blue: 0.042, alpha: 1.000)
        let strongBreeze = UIColor(red: 0.753, green: 0.972, blue: 0.049, alpha: 1.000)
        let highWind = UIColor(red: 0.993, green: 0.979, blue: 0.105, alpha: 1.000)
        let gale = UIColor(red: 0.981, green: 0.762, blue: 0.122, alpha: 1.000)
        let strongGale = UIColor(red: 0.952, green: 0.527, blue: 0.132, alpha: 1.000)
        let storm = UIColor(red: 0.932, green: 0.305, blue: 0.138, alpha: 1.000)
        let violentStorm = UIColor(red: 0.923, green: 0.145, blue: 0.140, alpha: 1.000)
        let hurricane = UIColor(red: 0.923, green: 0.145, blue: 0.140, alpha: 1.000)

        //// Variable Declarations
        let angle: CGFloat = -windDirection
        let speedText = "\(Int(round(round(windSpeed))))"
        let speedColor = windSpeed <= 0.3 ? calm : (windSpeed <= 1.5 ? lightAir : (windSpeed <= 3.3 ? lightBreeze : (windSpeed <= 5.5 ? gentleBreeze : (windSpeed <= 7.9 ? moderateBreeze : (windSpeed <= 10.7 ? freshBreeze : (windSpeed <= 13.8 ? strongBreeze : (windSpeed <= 17.1 ? highWind : (windSpeed <= 20.7 ? gale : (windSpeed <= 24.4 ? strongGale : (windSpeed <= 28.4 ? storm : (windSpeed <= 32.6 ? violentStorm : hurricane)))))))))))

        //// Bezier 2 Drawing
        context.saveGState()
        context.translateBy(x: 35, y: 35)
        context.rotate(by: -angle * CGFloat.pi/180)

        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 0.14, y: -32))
        bezier2Path.addCurve(to: CGPoint(x: 9.64, y: -22.51), controlPoint1: CGPoint(x: 0.14, y: -32), controlPoint2: CGPoint(x: 5.51, y: -26.63))
        bezier2Path.addCurve(to: CGPoint(x: 25, y: 0.57), controlPoint1: CGPoint(x: 18.66, y: -18.74), controlPoint2: CGPoint(x: 25, y: -9.82))
        bezier2Path.addCurve(to: CGPoint(x: -0, y: 25.57), controlPoint1: CGPoint(x: 25, y: 14.37), controlPoint2: CGPoint(x: 13.81, y: 25.57))
        bezier2Path.addCurve(to: CGPoint(x: -25, y: 0.57), controlPoint1: CGPoint(x: -13.81, y: 25.57), controlPoint2: CGPoint(x: -25, y: 14.37))
        bezier2Path.addCurve(to: CGPoint(x: -13.13, y: -20.71), controlPoint1: CGPoint(x: -25, y: -8.42), controlPoint2: CGPoint(x: -20.26, y: -16.3))
        bezier2Path.addCurve(to: CGPoint(x: -9.16, y: -22.7), controlPoint1: CGPoint(x: -11.88, y: -21.49), controlPoint2: CGPoint(x: -10.55, y: -22.15))
        bezier2Path.addCurve(to: CGPoint(x: 0.14, y: -32), controlPoint1: CGPoint(x: -5.06, y: -26.8), controlPoint2: CGPoint(x: 0.14, y: -32))
        bezier2Path.close()
        speedColor.setFill()
        bezier2Path.fill()

        context.restoreGState()


        //// Text Drawing
        let textRect = CGRect(x: 13, y: 19, width: 45, height: 33)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Medium", size: 24)!, NSForegroundColorAttributeName: UIColor.black, NSParagraphStyleAttributeName: textStyle]

        let textTextHeight: CGFloat = speedText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        speedText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    //// Generated Images

    public dynamic class func imageOfWindVane(windDirection: CGFloat = -56, windSpeed: CGFloat = 28.4) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 70, height: 70), false, 0)
            WeatherAppStyleKit.drawWindVane(windDirection: windDirection, windSpeed: windSpeed)

        let imageOfWindVane = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfWindVane
    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
